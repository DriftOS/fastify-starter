import { BaseOrchestrator, DefaultPerformanceTracker } from '@core/orchestration/index.js';
import type { PipelineStage } from '@core/orchestration/index.js';
import type {
  {{pascalCase name}}Context,
  {{pascalCase name}}Result,
  {{pascalCase name}}Input
} from './types/index.js';
import * as ops from './operations/index.js';

/**
 * {{pascalCase name}} Orchestrator (Calculation)
 *
 * Internal orchestrator - called via {{pascalCase name}}Service facade.
 *
 * Generated by: npm run generate
 */
export class {{pascalCase name}}Orchestrator extends BaseOrchestrator<
  {{pascalCase name}}Context,
  {{pascalCase name}}Result,
  {{pascalCase name}}Input
> {
  constructor() {
    super({
      name: '{{pascalCase name}}Orchestrator',
      timeout: 5000,
      enableMetrics: true,
      logErrors: true,
    });
  }

  protected async initializeContext(input: {{pascalCase name}}Input): Promise<{{pascalCase name}}Context> {
    return {
      ...input,
      policy: input.policy ?? { threshold: 0.75 },
      requestId: Math.random().toString(36).substr(2, 9),
      startTime: Date.now(),
      perfTracker: new DefaultPerformanceTracker(),
      results: {},
      errors: [],
      metadata: {
        orchestrator: this.getName(),
      },
      reasonCodes: []
    };
  }

  protected getPipeline(): PipelineStage<{{pascalCase name}}Context>[] {
    return [
      {{#each operations}}
      {
        name: '{{kebabCase this}}',
        operation: ops.{{camelCase this}},
        critical: true,
        timeout: 2000,
      },
      {{/each}}
    ];
  }

  protected buildResult(ctx: {{pascalCase name}}Context): {{pascalCase name}}Result {
    return {
      score: ctx.score,
      reasonCodes: ctx.reasonCodes,
      metadata: ctx.metadata
      // TODO: Add result fields from context
    };
  }
}
