import { {{pascalCase name}}Orchestrator } from './orchestrator.js';
import type { {{pascalCase name}}Result, {{pascalCase name}}Policy, {{pascalCase name}}Input } from './types/index.js';
import type { OrchestratorResult } from '@core/orchestration/index.js';

/**
 * {{pascalCase name}} Service (Calculation)
 *
 * Service facade implementing the singleton pattern.
 * Adapts external params to internal orchestrator.
 *
 * Generated by: npm run generate
 */

/**
 * Default policy
 */
const DEFAULT_POLICY: {{pascalCase name}}Policy = {
  threshold: 0.75
  // TODO: Add policy defaults
};

export class {{pascalCase name}}Service {
  private static instance: {{pascalCase name}}Service;
  private orchestrator: {{pascalCase name}}Orchestrator;

  private constructor() {
    this.orchestrator = new {{pascalCase name}}Orchestrator();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): {{pascalCase name}}Service {
    if (!{{pascalCase name}}Service.instance) {
      {{pascalCase name}}Service.instance = new {{pascalCase name}}Service();
    }
    return {{pascalCase name}}Service.instance;
  }

  /**
   * Calculate {{camelCase name}}
   *
   * @param id - Entity ID
   * @param data - Input data
   * @param policy - Optional policy override
   * @returns Calculation result
   */
  async calculate(
    id: string,
    data: Record<string, unknown>,
    policy: Partial<{{pascalCase name}}Policy> = {}
  ): Promise<OrchestratorResult<{{pascalCase name}}Result>> {
    const mergedPolicy: {{pascalCase name}}Policy = {
      ...DEFAULT_POLICY,
      ...policy
    };

    return this.orchestrator.execute({
      id,
      data,
      policy: mergedPolicy
    });
  }

  /**
   * Health check
   */
  public async healthCheck(): Promise<{ status: string; service: string }> {
    return {
      status: 'healthy',
      service: '{{pascalCase name}}Service',
    };
  }
}

// Export singleton instance
export const {{camelCase name}}Service = {{pascalCase name}}Service.getInstance();
