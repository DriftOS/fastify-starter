#!/usr/bin/env tsx

/**
 * Load Test Script - Simulates Production Traffic
 * 
 * Continuously sends requests to the API to generate metrics
 * and make the dashboard "light up" with data!
 */

const API_URL = process.env.API_URL || 'http://localhost:3000';
const REQUESTS_PER_SECOND = parseInt(process.env.RPS || '1', 10); // Default 1 req/s (safe for 100/min rate limit)
const DURATION_MINUTES = parseInt(process.env.DURATION || '60', 10);
const RANDOMIZE = process.env.RANDOMIZE !== 'false'; // Enable randomization by default
const JITTER_PERCENT = parseFloat(process.env.JITTER || '30'); // 30% timing variance

interface Stats {
  total: number;
  success: number;
  errors: number;
  rateLimited: number;
  avgLatency: number;
  latencies: number[];
}

const stats: Stats = {
  total: 0,
  success: 0,
  errors: 0,
  rateLimited: 0,
  avgLatency: 0,
  latencies: [],
};

let authToken: string = '';

const TODO_TITLES = [
  'Build awesome feature',
  'Fix critical bug',
  'Write documentation',
  'Review pull request',
  'Deploy to production',
  'Optimize performance',
  'Refactor legacy code',
  'Add unit tests',
  'Update dependencies',
  'Design new UI',
  'Implement authentication',
  'Setup CI/CD pipeline',
  'Monitor metrics',
  'Debug issue',
  'Prepare release',
];

/**
 * Login and get auth token
 */
async function login(): Promise<string> {
  const credentials = {
    email: 'loadtest@example.com',
    password: 'LoadTest123!',
  };
  
  try {
    // Try to login first
    const loginResponse = await fetch(`${API_URL}/api/v1/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials),
    });
    
    if (loginResponse.ok) {
      const data = await loginResponse.json();
      return data.data.token;
    }
    
    // If login fails, try to register
    const registerResponse = await fetch(`${API_URL}/api/v1/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...credentials,
        name: 'Load Test User',
      }),
    });
    
    if (registerResponse.ok) {
      const data = await registerResponse.json();
      return data.data.token;
    }
    
    throw new Error('Failed to login or register');
  } catch (error) {
    console.error('‚ùå Authentication failed:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

/**
 * Create a todo via API
 */
async function createTodo(): Promise<void> {
  const title = TODO_TITLES[Math.floor(Math.random() * TODO_TITLES.length)];
  const start = Date.now();
  
  try {
    const response = await fetch(`${API_URL}/api/v1/todos`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`,
      },
      body: JSON.stringify({ 
        title,
        description: 'Generated by load tester'
      }),
    });
    
    const latency = Date.now() - start;
    stats.latencies.push(latency);
    stats.total++;
    
    if (response.ok) {
      stats.success++;
    } else if (response.status === 429) {
      stats.rateLimited++;
      stats.errors++;
      // Don't log every rate limit error, just track it
    } else {
      stats.errors++;
      console.error(`‚ùå Error ${response.status}: ${await response.text()}`);
    }
  } catch (error) {
    stats.total++;
    stats.errors++;
    console.error(`‚ùå Request failed:`, error instanceof Error ? error.message : error);
  }
}

/**
 * Calculate and display stats
 */
function displayStats(): void {
  if (stats.latencies.length === 0) return;
  
  const sorted = [...stats.latencies].sort((a, b) => a - b);
  const avg = stats.latencies.reduce((a, b) => a + b, 0) / stats.latencies.length;
  const p50 = sorted[Math.floor(sorted.length * 0.5)];
  const p95 = sorted[Math.floor(sorted.length * 0.95)];
  const p99 = sorted[Math.floor(sorted.length * 0.99)];
  
  const successRate = ((stats.success / stats.total) * 100).toFixed(1);
  const errorRate = ((stats.errors / stats.total) * 100).toFixed(1);
  
  console.clear();
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë                                                            ‚ïë');
  console.log('‚ïë   üöÄ LOAD TEST GENERATOR - LIGHTING UP DASHBOARDS!        ‚ïë');
  console.log('‚ïë                                                            ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('');
  console.log(`üìä REQUESTS`);
  console.log(`   Total:       ${stats.total.toString().padStart(8)}`);
  console.log(`   Success:     ${stats.success.toString().padStart(8)} (${successRate}%)`);
  console.log(`   Errors:      ${stats.errors.toString().padStart(8)} (${errorRate}%)`);
  if (stats.rateLimited > 0) {
    console.log(`   Rate Limited:${stats.rateLimited.toString().padStart(8)} ‚ö†Ô∏è`);
  }
  console.log(`   Rate:        ${REQUESTS_PER_SECOND.toString().padStart(8)} req/s (avg)`);
  console.log('');
  console.log(`‚ö° LATENCY`);
  console.log(`   Avg:         ${avg.toFixed(1).padStart(8)} ms`);
  console.log(`   P50:         ${p50.toString().padStart(8)} ms`);
  console.log(`   P95:         ${p95.toString().padStart(8)} ms`);
  console.log(`   P99:         ${p99.toString().padStart(8)} ms`);
  console.log('');
  console.log(`üéØ DASHBOARD`);
  console.log(`   URL:         ${API_URL}`);
  console.log(`   Grafana:     http://localhost:3001`);
  console.log('');
  console.log(`üí° Press Ctrl+C to stop`);
  console.log('');
}

/**
 * Calculate next request delay with jitter
 */
function getNextDelay(baseInterval: number): number {
  if (!RANDOMIZE) {
    return baseInterval;
  }
  
  // Add jitter: random variance of ¬±JITTER_PERCENT
  const jitterAmount = baseInterval * (JITTER_PERCENT / 100);
  const minDelay = baseInterval - jitterAmount;
  const maxDelay = baseInterval + jitterAmount;
  
  return Math.random() * (maxDelay - minDelay) + minDelay;
}

/**
 * Main load test loop
 */
async function runLoadTest(): Promise<void> {
  console.log('üöÄ Starting load test...\n');
  
  // Login first
  console.log('üîê Authenticating...');
  authToken = await login();
  console.log('‚úÖ Authentication successful!\n');
  
  console.log(`Target: ${API_URL}/api/v1/todos`);
  console.log(`Rate: ${REQUESTS_PER_SECOND} req/s (avg)`);
  console.log(`Randomized: ${RANDOMIZE ? `Yes (¬±${JITTER_PERCENT}% jitter)` : 'No'}`);
  console.log(`Rate Limit: 100 req/min (built-in)`);
  console.log(`Duration: ${DURATION_MINUTES} minutes\n`);
  
  if (REQUESTS_PER_SECOND > 1.5) {
    console.log('‚ö†Ô∏è  WARNING: RPS > 1.5 may hit rate limits (100/min)');
    console.log('    Consider: RPS=1 for safe continuous testing\n');
  }
  
  const baseInterval = 1000 / REQUESTS_PER_SECOND;
  const endTime = Date.now() + (DURATION_MINUTES * 60 * 1000);
  
  // Display stats every second
  const statsInterval = setInterval(displayStats, 1000);
  
  // Recursive function for randomized intervals
  const scheduleNextRequest = () => {
    if (Date.now() >= endTime) {
      clearInterval(statsInterval);
      displayStats();
      console.log('\n‚úÖ Load test complete!\n');
      process.exit(0);
      return;
    }
    
    // Send request
    createTodo().catch(console.error);
    
    // Schedule next request with jitter
    const nextDelay = getNextDelay(baseInterval);
    setTimeout(scheduleNextRequest, nextDelay);
  };
  
  // Start the first request
  scheduleNextRequest();
  
  // Handle Ctrl+C gracefully
  process.on('SIGINT', () => {
    clearInterval(statsInterval);
    displayStats();
    console.log('\n‚è∏Ô∏è  Load test stopped by user\n');
    process.exit(0);
  });
}

// Start the load test
runLoadTest().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
